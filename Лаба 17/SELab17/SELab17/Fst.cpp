#include "stdafx.h" 

namespace FST
{
    // Конструктор класса RELATION, инициализирует символ и номер следующего узла
    RELATION::RELATION(unsigned char c, short nn)
    {
        symbol = c; // Устанавливаем символ
        nnode = nn; // Устанавливаем номер следующего узла
    }

    // Конструктор по умолчанию для класса NODE, инициализирует количество отношений и указатель на массив отношений
    NODE::NODE()
    {
        n_relation = 0; // Инициализация количества отношений нулем
        relations = nullptr; // Указатель на отношения пустой
    }

    // Конструктор для класса NODE с параметрами: количество отношений, первый элемент отношений и дополнительные отношения
    NODE::NODE(short n, RELATION rel, ...)
    {
        n_relation = n; // Устанавливаем количество отношений
        RELATION* p = &rel; // Получаем указатель на первый элемент отношений
        relations = new RELATION[n]; // Выделяем память под массив отношений
        for (short i = 0; i < n; i++) // Цикл для копирования всех отношений
        {
            relations[i] = p[i]; // Копируем каждый элемент отношений в массив
        }
    }

    // Конструктор для класса FST с параметрами: входная строка, количество состояний и первый узел
    FST::FST(std::string s, short ns, NODE n, ...)
    {
        string = s; // Устанавливаем входную строку
        nstates = ns; // Устанавливаем количество состояний
        nodes = new NODE[ns]; // Выделяем память под массив узлов
        NODE* p = &n; // Получаем указатель на первый узел
        for (int k = 0; k < ns; k++) // Цикл для копирования всех узлов
        {
            nodes[k] = p[k]; // Копируем каждый узел в массив узлов
        }
        rstates = new short[nstates]; // Выделяем память под массив состояний
        memset(rstates, 0xff, sizeof(short) * nstates); // Заполняем массив состояний значениями 0xff
        rstates[0] = 0; // Устанавливаем начальное состояние
        position = -1; // Устанавливаем начальную позицию
    }

    // Функция для выполнения одного шага автомата
    bool step(FST& fst, short*& rstates)
    {
        bool rc = false; // Переменная для хранения результата
        std::swap(rstates, fst.rstates); // Меняем местами временные состояния и состояния автомата
        for (short i = 0; i < fst.nstates; i++) // Цикл по состояниям
        {
            if (rstates[i] == fst.position) // Проверяем, находится ли текущее состояние в нужной позиции
                for (short j = 0; j < fst.nodes[i].n_relation; j++) // Цикл по всем отношениям узла
                {
                    if (fst.nodes[i].relations[j].symbol == fst.string[fst.position]) // Если символ совпадает с символом во входной строке
                    {
                        fst.rstates[fst.nodes[i].relations[j].nnode] = fst.position + 1; // Переходим к следующему состоянию
                        rc = true; // Обновляем флаг, что шаг выполнен успешно
                    }
                }
        }
        return rc; // Возвращаем результат
    }

    // Функция для выполнения автомата
    bool execute(FST& fst)
    {
        short* rstates = new short[fst.nstates]; // Выделяем память под временные состояния
        memset(rstates, 0xff, sizeof(short) * fst.nstates); // Заполняем временные состояния значениями 0xff
        short lstring = fst.string.length(); // Получаем длину входной строки
        bool rc = true; // Переменная для хранения результата
        for (short i = 0; i < lstring && rc; i++) // Цикл по символам строки, пока не конец строки или не найдено несоответствие
        {
            fst.position++; // Увеличиваем позицию
            rc = step(fst, rstates); // Выполняем шаг автомата
        }
        fst.rstates[0] = 0; // Восстанавливаем начальное состояние
        //delete[] rstates; // Комментарий: можно освободить память
        return (rc ? (fst.rstates[fst.nstates - 1] == lstring) : rc); // Возвращаем true, если последний элемент состояний равен длине строки
    }

    // Функция для вывода ошибки
    void WriteError(Error::ERROR e)
    {
        std::cout << "Ошибка разбора строки" << std::endl; // Сообщение об ошибке
        std::cout << "Ошибка разбора в строке: " << e.inext.buff << std::endl; // Вывод строки, в которой произошла ошибка
        std::cout << "Позиция: " << e.inext.fstline + 1; // Вывод позиции ошибки
    }
}
